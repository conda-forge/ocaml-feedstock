#**************************************************************************
#*                                                                        *
#*                                 OCaml                                  *
#*                                                                        *
#*                          Samuel Hym, Tarides                           *
#*                                                                        *
#*   Copyright 2024 Tarides                                               *
#*                                                                        *
#*   All rights reserved.  This file is distributed under the terms of    *
#*   the GNU Lesser General Public License version 2.1, with the          *
#*   special exception on linking described in the file LICENSE.          *
#*                                                                        *
#**************************************************************************

# Recipes to build a cross compiler (_not_ cross-compiling the compiler), aka
# generating code that will run on `target`, assuming that a non-cross OCaml
# compiler (so targetting our build machine) of the same version is available in
# $PATH

# As the cross compiler will be linked with the _build_ version of
# libcomprmarsh, we cannot rely on the detection of zstd done during `configure`
# (as it would have detected the _target_ version). So we recover the flags to
# link with zstd of the non-cross compiler.
# ZSTD_LIBS can be overridden from command line for cross-compilation (to use HOST libs)
# If not provided, fall back to native ocamlopt's compression_c_libraries config
ZSTD_LIBS ?= $(shell ocamlopt -config-var compression_c_libraries)
HOST_ZSTD_LIBS=ZSTD_LIBS=$(ZSTD_LIBS)

# The build system adds various include directories which pertain to the current
# tree, including -I runtime, which is necessary for -custom executables.
# ocamltest is always a -custom executable, but some others (ocamldoc; the
# debugger, etc.) are only -custom in specific circumstances. It is therefore
# fiddly to change this in the main build system, so we perform a slightly
# different trick by ensuring that "+" is the first entry in VPATH. This will
# put the host compiler's standard library (and consequently its runtime
# objects) well above the .a files found with -I runtime. For now, this seems
# the least nefarious way of ensuring that the bytecode compiler has the C
# headers in runtime/caml available without breaking builds with an external
# ocamlopt.
# CRITICAL: Only set VPATH when NOT installing. During install, VPATH causes
# Make to find OLD unix.cmxa from native stdlib before the freshly built one
# in otherlibs/unix/. Set INSTALLING=1 during installcross to skip this.
ifneq ($(INSTALLING),1)
VPATH := + $(VPATH)
endif

# Export OCAMLLIB (will be set for specific targets that need it)
export OCAMLLIB

# SAK_CC and SAK_LINK should be set to build-machine compiler when cross-compiling
# SAK is a build tool that must run on the BUILD machine, not the TARGET
# Default to CC if SAK_CC is not defined (native build case)
SAK_CC ?= $(CC)
# SAK_CFLAGS: CFLAGS for BUILD machine (sak runs on build, not target)
# Must NOT contain target-specific flags like -mtune=power8
SAK_CFLAGS ?= $(CFLAGS)
SAK_LINK ?= $(SAK_CC) $(OC_LDFLAGS) $(LDFLAGS) $(OUTPUTEXE)$(1) $(2)

# Override SAK_BUILD to use SAK_CC/SAK_CFLAGS instead of CC/CFLAGS for cross-compilation
# sak is a build tool that must run on the BUILD machine
SAK_BUILD = $(SAK_LINK) $(OC_CFLAGS) $(SAK_CFLAGS) $(OC_CPPFLAGS) $(CPPFLAGS)

# CROSS_CC/CROSS_AR must be set on command line for cross-compilation.
# These are passed through to sub-makes for C libraries (otherlibs).
# We can't use CC="$(CC)" because $(CC) gets value from Makefile.config (BUILD compiler),
# not the command-line override (TARGET cross-compiler).
CROSS_CC ?= $(CC)
CROSS_AR ?= $(AR)

# CROSS_MKLIB: wrapper for ocamlmklib that uses CROSS_CC/CROSS_AR.
# ocamlmklib has Config.ar and Config.mkdll baked in from compile time (BUILD tools).
# For cross-compilation, we need a wrapper that uses TARGET cross-tools.
# Set to cross-ocamlmklib.sh on command line; defaults to ocamlmklib for native builds.
CROSS_MKLIB ?= ocamlmklib

# CAMLOPT can be overridden on command line for cross-compilation.
# Stage 2 (crossopt): use native ocamlopt from PATH
# Stage 3 (crosscompiledopt): use cross-compiler from _cross/bin to produce target binaries
CAMLOPT ?= ocamlopt

# CROSS_OVERRIDES for sub-makes.
# CC/AR must be cross-compiler for C stub libraries in otherlibs.
# CFLAGS/LDFLAGS must include target-specific flags (e.g., -isysroot for macOS ARM64)
# On macOS, -isysroot is needed in both CFLAGS and LDFLAGS for proper SDK linkage
# CAMLC=ocamlc uses the installed ocamlc from PATH (required for dynlink, otherlibs)
# MKLIB=$(CROSS_MKLIB) uses cross-ocamlmklib.sh wrapper for cross-compilation:
#   - The native ocamlmklib has BUILD linker baked in (Config.mkdll, Config.ar)
#   - The wrapper script uses CROSS_CC/CROSS_AR for proper cross-compilation
#   - For native builds, CROSS_MKLIB defaults to ocamlmklib
# MKEXE/MKDLL: Must include -isysroot for macOS ARM64 cross-compilation
#   - OCaml's stdlib/Makefile uses $(MKEXE) directly without $(LDFLAGS)
#   - Without explicit pass-through, linker finds wrong SDK
CROSS_MKEXE ?= $(MKEXE)
CROSS_MKDLL ?= $(MKDLL)

CROSS_OVERRIDES=OCAMLRUN=ocamlrun NEW_OCAMLRUN=ocamlrun \
  BOOT_OCAMLLEX=ocamllex OCAMLYACC=ocamlyacc \
  CAMLC=ocamlc MKLIB="$(CROSS_MKLIB)" \
  CC="$(CROSS_CC)" AR="$(CROSS_AR)" CFLAGS="$(CFLAGS)" LDFLAGS="$(LDFLAGS)" \
  MKEXE="$(CROSS_MKEXE)" MKDLL="$(CROSS_MKDLL)"

# CROSS_OTHERLIBS_OVERRIDES: same as CROSS_OVERRIDES
CROSS_OTHERLIBS_OVERRIDES = $(CROSS_OVERRIDES)

# NATIVE_AS/NATIVE_CC: Passed from build-cross-compiler.sh, saved before CONDA_OCAML_* override
# These are the native (BUILD machine) assembler/compiler for building native tools
# NATIVE_ASM is the assembler command (e.g., "clang -c" on macOS, "as" on Linux)
NATIVE_AS ?= as
NATIVE_ASM ?= $(NATIVE_AS)
NATIVE_CC ?= $(CC)

# NATIVE_OVERRIDES: For building NATIVE tools (ocamlc.opt, ocamlopt.opt, profiling.cmx)
# These run on the BUILD machine and must use BUILD tools, NOT cross-compiler.
# Does NOT include CC/AR overrides - uses defaults from Makefile.config (BUILD compiler)
# NOTE: CONDA_OCAML_AS/CC are set as ENVIRONMENT VARIABLES at call sites (lines 207, 219)
# NOT here, because NATIVE_ASM contains spaces (e.g., "clang -c") which breaks
# make variable passing (spaces split into separate args, -c becomes invalid option)
NATIVE_OVERRIDES=OCAMLRUN=ocamlrun NEW_OCAMLRUN=ocamlrun \
  BOOT_OCAMLLEX=ocamllex OCAMLYACC=ocamlyacc \
  CAMLC=ocamlc MKLIB="$(CROSS_MKLIB)"

# NATIVE_COMPILER_OVERRIDES: For building native compilers with native tools
# CRITICAL: Does NOT include CC="$(CROSS_CC)" - we need BUILD CC for native tools
NATIVE_COMPILER_OVERRIDES=$(NATIVE_OVERRIDES) CAMLC=ocamlc CAMLOPT=$(CAMLOPT) \
  BEST_OCAMLC=ocamlc BEST_OCAMLOPT=$(CAMLOPT) BEST_OCAMLLEX=ocamllex

# CAMLOPT is now a variable that can be overridden from command line
CROSS_COMPILER_OVERRIDES=$(CROSS_OVERRIDES) CAMLC=ocamlc CAMLOPT=$(CAMLOPT) \
  BEST_OCAMLC=ocamlc BEST_OCAMLOPT=$(CAMLOPT) BEST_OCAMLLEX=ocamllex
CROSS_COMPILERLIBS_OVERRIDES=$(CROSS_OVERRIDES) CAMLC=ocamlc \
  CAMLOPT="$(abspath $(ROOTDIR))/ocamlopt.opt$(EXE) $(STDLIBFLAGS)"

CROSSCOMPILED_COMPILERLIBS_OVERRIDES=$(CROSS_OVERRIDES) CAMLC=ocamlc \
  CAMLOPT="$(CAMLOPT) $(STDLIBFLAGS)"

ifeq "$(BOOTSTRAPPING_FLEXDLL)" "true"
# Declare flexlink to be an 'old' file, so that make doesn't try to rebuild it
# with the build rules in `Makefile`; its build is driven by the `cross-flexdll`
# recipe provided here instead
OLDS := -o $(BYTE_BINDIR)/flexlink$(EXE)
else
OLDS :=
endif

# The compiler libs that should be rebuilt for target (they are first built for
# host as part of the .opt compilers)
CROSSCOMPILERLIBS := $(addprefix compilerlibs/,$(addsuffix .cmxa,\
    ocamlcommon ocamlmiddleend ocamlbytecomp ocamloptcomp ocamltoplevel))

# RUNTIME_VARS: variables that must be passed to runtimeopt for cross-compilation
# ARCH selects the correct .S file (arm64.S vs amd64.S)
# AS/ASPP/CC are the cross-toolchain for assembling/compiling
# SAK_CC/SAK_CFLAGS are for the sak tool which must run on BUILD machine
# SAK_LINK uses $$ escaping so $(1) and $(2) survive to the sub-make's $(call SAK_LINK,...)
# Values must be quoted because ASPP contains spaces (e.g., "gcc -c")
# runtime_ASM_OBJECTS is hardcoded at configure time (Makefile.build_config),
# must override to use correct $(ARCH).o for cross-compilation
# LDFLAGS passed here is for the TARGET cross-linker (e.g., -fuse-ld=lld on macOS)
# SAK_LINK uses $(SAK_LDFLAGS) NOT $(LDFLAGS) - SAK runs on BUILD machine, not TARGET
# AR must be passed to create archives with correct format (llvm-ar on macOS for ld64 compat)
RUNTIME_VARS = ARCH=$(ARCH) AR='$(AR)' AS='$(AS)' ASPP='$(ASPP)' CC='$(CC)' LDFLAGS='$(LDFLAGS)' \
  SAK_CC='$(SAK_CC)' SAK_CFLAGS='$(SAK_CFLAGS)' \
  'SAK_LINK=$(SAK_CC) $(SAK_LDFLAGS) $$(OUTPUTEXE)$$(1) $$(2)' \
  runtime_ASM_OBJECTS='runtime/$(ARCH).o'

# BYTECODE_RUNTIME_VARS: for building bytecode runtime on BUILD machine (not cross-compiled)
# ocamlrun must run on the BUILD machine, so use BUILD compiler (not cross-compiler)
# The x86_64 ocamlrun from Stage 1 (_native/bin) is available via PATH
# SAK tool also runs on BUILD machine
# SAK_LDFLAGS: linker flags for BUILD machine (e.g., -fuse-ld=lld on macOS)
# SAK_AR: archiver for BUILD machine (llvm-ar on macOS for ld64 compatibility)
SAK_LDFLAGS ?=
SAK_AR ?= $(AR)
BYTECODE_RUNTIME_VARS = \
  SAK_CC='$(SAK_CC)' SAK_CFLAGS='$(SAK_CFLAGS)' \
  'SAK_LINK=$(SAK_CC) $(SAK_LDFLAGS) $$(OUTPUTEXE)$$(1) $$(2)'

.PHONY: crossopt
ifeq "$(BOOTSTRAPPING_FLEXDLL)" "true"
crossopt: cross-flexdll
	# Build bytecode runtime with BUILD compiler (ocamlrun runs on BUILD machine)
	# SAK_* override MAKEFLAGS to prevent cross-compiler flags (e.g., -mtune=power8)
	$(MAKE) runtime-all CC=$(SAK_CC) CFLAGS="$(SAK_CFLAGS)" LDFLAGS="$(SAK_LDFLAGS)" AR="$(SAK_AR)" $(BYTECODE_RUNTIME_VARS) $(OLDS)
else
crossopt:
	# Build bytecode runtime with BUILD compiler (ocamlrun runs on BUILD machine)
	# SAK_* override MAKEFLAGS to prevent cross-compiler flags (e.g., -mtune=power8)
	$(MAKE) runtime-all CC=$(SAK_CC) CFLAGS="$(SAK_CFLAGS)" LDFLAGS="$(SAK_LDFLAGS)" AR="$(SAK_AR)" $(BYTECODE_RUNTIME_VARS) $(OLDS)
endif
	$(MAKE) ocamlc $(TOOLS_BYTECODE_TARGETS) expunge$(EXE) \
	  $(CROSS_COMPILER_OVERRIDES) $(OLDS)
	# Build stdlib directly (not via library or library-cross targets)
	# - library depends on ocamlc which triggers rebuild
	# - library-cross sets OCAMLRUN=../runtime/ocamlrun which doesn't work for cross
	# - COMPILER_DEPS= disables the file dependency check on ../ocamlc
	# - CAMLC=ocamlc uses the installed ocamlc from PATH
	$(MAKE) -C stdlib all CAMLC=ocamlc COMPILER_DEPS= $(CROSS_OVERRIDES) $(OLDS)
	$(MAKE) ocamlyacc $(CROSS_OVERRIDES) $(OLDS)
	$(MAKE) ocamllex $(CROSS_COMPILER_OVERRIDES) $(OLDS)
	$(MAKE) ocaml $(CROSS_COMPILER_OVERRIDES) $(OLDS)
	$(MAKE) dynlink-all $(CROSS_OVERRIDES) $(OLDS)
	$(MAKE) -C otherlibs all $(CROSS_OTHERLIBS_OVERRIDES) $(OLDS)
	$(MAKE) runtimeopt $(RUNTIME_VARS) $(OLDS)
	# Build native compilers (BUILD platform binaries) using CAMLOPT from PATH
	# Set CONDA_OCAML_* env vars so ocamlopt finds NATIVE tools (not cross-tools)
	# NATIVE_ASM includes "-c" for macOS clang (space-separated, hence quoted)
	CONDA_OCAML_AS="$(NATIVE_ASM)" CONDA_OCAML_CC="$(NATIVE_CC)" \
	  $(MAKE) ocamlc.opt ocamlopt.opt $(TOOLS_NATIVE_TARGETS) \
	  $(NATIVE_COMPILER_OVERRIDES) OCAMLOPT=$(CAMLOPT) "$(HOST_ZSTD_LIBS)" $(OLDS)
	# CRITICAL FIX: Clean LIBDIR before building to prevent CRC mismatches
	# If LIBDIR has old .cmi files, unix.cmxa might find them via Config.standard_library
	# while stdlib.cmxa uses local .cmi files, causing "inconsistent assumptions"
	# By ensuring LIBDIR is empty, both use .cmi files from work tree
	@echo "=== Cleaning LIBDIR to ensure consistent .cmi usage ==="
	@rm -rf "$(LIBDIR)"
	@mkdir -p "$(LIBDIR)"
	# Build stdlib native directly using the FRESHLY BUILT cross-compiler (5.4.0 approach)
	# CRITICAL: Use absolute path to cross-compiler - ROOTDIR is relative (.) and breaks with -C
	# COMPILER_DEPS= disables bytecode compiler file dependency (for .cmi files)
	# OPTCOMPILER= disables native compiler file dependency (for .cmx files)
	$(MAKE) -C stdlib allopt CAMLOPT="$(abspath $(ROOTDIR))/ocamlopt.opt" OPTCOMPILER= COMPILER_DEPS= $(CROSS_OVERRIDES) $(OLDS)
	# CRITICAL FIX: Create complete stdlib environment at LIBDIR with fresh stdlib AND
	# native otherlibs dependencies (like Unix.cmi for systhreads).
	# Then set OCAMLLIB=LIBDIR so ocamlopt.opt finds fresh stdlib.cmxa for linking
	# while still being able to find Unix.cmi from native build.
	@echo "=== Setting up LIBDIR with fresh stdlib + native otherlibs deps ==="
	@mkdir -p "$(LIBDIR)"
	# Copy fresh stdlib (with NEW CRCs)
	@cp stdlib/*.cmi stdlib/*.cmo stdlib/*.cma stdlib/*.cmxa stdlib/*.a "$(LIBDIR)/" 2>/dev/null || true
	@cp stdlib/*.cmx "$(LIBDIR)/" 2>/dev/null || true
	# Copy .cmi and .cmx files from native otherlibs (for dependencies like Unix.cmi/cmx that systhreads needs)
	# DO NOT copy .cma/.cmxa - those have old CRCs and would cause "inconsistent assumptions" errors
	# The .cmi/.cmx files are for compilation/linking dependencies, not the final libraries
	@mkdir -p "$(LIBDIR)/unix" "$(LIBDIR)/str" "$(LIBDIR)/dynlink" "$(LIBDIR)/systhreads" "$(LIBDIR)/runtime_events"
	# Copy .cmi files (separate commands to handle missing files gracefully)
	@cp "$(NATIVE_STDLIB)/unix/"*.cmi "$(LIBDIR)/unix/" 2>/dev/null || true
	@cp "$(NATIVE_STDLIB)/str/"*.cmi "$(LIBDIR)/str/" 2>/dev/null || true
	@cp "$(NATIVE_STDLIB)/dynlink/"*.cmi "$(LIBDIR)/dynlink/" 2>/dev/null || true
	@cp "$(NATIVE_STDLIB)/systhreads/"*.cmi "$(LIBDIR)/systhreads/" 2>/dev/null || true
	@cp "$(NATIVE_STDLIB)/runtime_events/"*.cmi "$(LIBDIR)/runtime_events/" 2>/dev/null || true
	# Copy .cmx files (separate commands - may not exist if native build didn't install them)
	@cp "$(NATIVE_STDLIB)/unix/"*.cmx "$(LIBDIR)/unix/" 2>/dev/null || true
	@cp "$(NATIVE_STDLIB)/str/"*.cmx "$(LIBDIR)/str/" 2>/dev/null || true
	@cp "$(NATIVE_STDLIB)/dynlink/"*.cmx "$(LIBDIR)/dynlink/" 2>/dev/null || true
	@cp "$(NATIVE_STDLIB)/systhreads/"*.cmx "$(LIBDIR)/systhreads/" 2>/dev/null || true
	@cp "$(NATIVE_STDLIB)/runtime_events/"*.cmx "$(LIBDIR)/runtime_events/" 2>/dev/null || true
	# CRITICAL: Clean otherlibs .cmx files to force rebuild with fresh stdlib CRCs
	# Without this, existing unix.cmx from native build won't be rebuilt
	@echo "=== Cleaning otherlibs .cmx to force rebuild ==="
	@rm -f otherlibs/unix/*.cmx otherlibs/unix/*.cmi otherlibs/unix/*.o
	@rm -f otherlibs/str/*.cmx otherlibs/str/*.cmi otherlibs/str/*.o
	@rm -f otherlibs/dynlink/*.cmx otherlibs/dynlink/*.cmi otherlibs/dynlink/*.o
	@rm -f otherlibs/dynlink/native/*.cmx otherlibs/dynlink/native/*.cmi otherlibs/dynlink/native/*.o
	@rm -f otherlibs/systhreads/*.cmx otherlibs/systhreads/*.cmi otherlibs/systhreads/*.o
	@rm -f otherlibs/runtime_events/*.cmx otherlibs/runtime_events/*.cmi otherlibs/runtime_events/*.o
	# CRITICAL: Build otherlibrariesopt with OCAMLLIB pointing to LIBDIR
	# This overrides Config.standard_library (baked into ocamlopt.opt at configure time)
	# which points to NATIVE_STDLIB with OLD CRCs from native build.
	# LIBDIR now has: fresh stdlib.cmxa + native otherlibs for dependencies
	# BEST_OCAMLOPT must also be overridden to use freshly built cross-compiler.
	OCAMLLIB="$(LIBDIR)" \
	  $(MAKE) otherlibrariesopt \
	  CAMLOPT="$(abspath $(ROOTDIR))/ocamlopt.opt" \
	  BEST_OCAMLOPT="$(abspath $(ROOTDIR))/ocamlopt.opt" \
	  $(CROSS_OTHERLIBS_OVERRIDES) $(OLDS)
	# CRITICAL: Rebuild bytecode otherlibs with OCAMLLIB override
	# Same CRC issue as native - ocamlc's Config.standard_library points to NATIVE_STDLIB
	# which has OLD CRCs from native build. Must override to use fresh stdlib from LIBDIR.
	@echo "=== Cleaning otherlibs bytecode to force rebuild with fresh CRCs ==="
	# Remove ALL bytecode artifacts (.cmo, .cmi, .cma) to force complete rebuild
	# OLD .cmi files from earlier build (lines 194-195) would cause CRC mismatch
	@rm -f otherlibs/unix/*.cmo otherlibs/unix/*.cmi otherlibs/unix/*.cma
	@rm -f otherlibs/str/*.cmo otherlibs/str/*.cmi otherlibs/str/*.cma
	@rm -f otherlibs/dynlink/*.cmo otherlibs/dynlink/*.cmi otherlibs/dynlink/*.cma
	@rm -f otherlibs/systhreads/*.cmo otherlibs/systhreads/*.cmi otherlibs/systhreads/*.cma
	@rm -f otherlibs/runtime_events/*.cmo otherlibs/runtime_events/*.cmi otherlibs/runtime_events/*.cma
	@rm -f otherlibs/dynlink/byte/*.cmo 2>/dev/null || true
	# Remove OLD .cmi from LIBDIR subdirs (copied from NATIVE_STDLIB at line 229)
	# These would pollute bytecode build with old CRCs via -I $(OCAMLLIB)/unix path
	@rm -f "$(LIBDIR)/unix/"*.cmi "$(LIBDIR)/str/"*.cmi "$(LIBDIR)/dynlink/"*.cmi
	@rm -f "$(LIBDIR)/systhreads/"*.cmi "$(LIBDIR)/runtime_events/"*.cmi
	@echo "=== Rebuilding bytecode otherlibs with OCAMLLIB override ==="
	# Build unix FIRST (no external otherlib dependencies)
	OCAMLLIB="$(LIBDIR)" $(MAKE) -C otherlibs/unix all $(CROSS_OTHERLIBS_OVERRIDES) $(OLDS)
	# Copy fresh Unix.cmi to LIBDIR for systhreads dependency
	@echo "=== Copying fresh Unix.cmi to LIBDIR for systhreads ==="
	@cp otherlibs/unix/*.cmi "$(LIBDIR)/unix/"
	# Build str (no Unix dependency)
	OCAMLLIB="$(LIBDIR)" $(MAKE) -C otherlibs/str all $(CROSS_OTHERLIBS_OVERRIDES) $(OLDS)
	@cp otherlibs/str/*.cmi "$(LIBDIR)/str/"
	# Build dynlink
	OCAMLLIB="$(LIBDIR)" $(MAKE) dynlink-all $(CROSS_OVERRIDES) $(OLDS)
	@cp otherlibs/dynlink/*.cmi "$(LIBDIR)/dynlink/" 2>/dev/null || true
	# Build runtime_events (no external deps)
	OCAMLLIB="$(LIBDIR)" $(MAKE) -C otherlibs/runtime_events all $(CROSS_OTHERLIBS_OVERRIDES) $(OLDS)
	@cp otherlibs/runtime_events/*.cmi "$(LIBDIR)/runtime_events/"
	# Build systhreads LAST (depends on Unix.cmi now in LIBDIR)
	OCAMLLIB="$(LIBDIR)" $(MAKE) -C otherlibs/systhreads all $(CROSS_OTHERLIBS_OVERRIDES) $(OLDS)
	@cp otherlibs/systhreads/*.cmi "$(LIBDIR)/systhreads/"
	# Build ocamltoolsopt separately - these link against NATIVE stdlib (not cross)
	# so they should NOT have OCAMLLIB override
	$(MAKE) ocamltoolsopt \
	  CAMLOPT="$(abspath $(ROOTDIR))/ocamlopt.opt" \
	  BEST_OCAMLOPT="$(abspath $(ROOTDIR))/ocamlopt.opt" \
	  $(OLDS)
	# NOTE: Do NOT copy files to NATIVE_STDLIB!
	# NATIVE_STDLIB is the installed native compiler that gets packaged.
	# Overwriting its .cmi files with cross-built versions causes CRC mismatch:
	# - native unix.cma has OLD CRCs (from native build)
	# - if we copy NEW unix.cmi here, users get OLD cma + NEW cmi = error
	# The cross-compiler should use LIBDIR for its own files, not modify NATIVE_STDLIB.
	# ocamltoolsopt.opt builds NATIVE tools (ocamllex.opt etc.) - need NATIVE overrides
	CONDA_OCAML_AS="$(NATIVE_ASM)" CONDA_OCAML_CC="$(NATIVE_CC)" \
	  $(MAKE) ocamltoolsopt.opt $(NATIVE_COMPILER_OVERRIDES) $(OLDS)
	# Copy stublibs to where the cross-compiler expects them
	# The compiler has Config.standard_library baked in (pointing to PREFIX/lib/ocaml)
	# and looks for stublibs relative to that path. We must copy before CROSSCOMPILERLIBS.
	@echo "=== Copying stublibs to $(LIBDIR)/stublibs ==="
	mkdir -p "$(LIBDIR)/stublibs"
	@for f in otherlibs/*/dll*.so; do \
	  if [ -f "$$f" ]; then \
	    echo "  Copying: $$f"; \
	    cp "$$f" "$(LIBDIR)/stublibs/"; \
	  fi; \
	done
	# We now build the compiler libs again, but for target this time
	rm -f $(ocamlcommon_NCOBJS) $(ocamlmiddleend_NCOBJS) \
	  $(ocamlbytecomp_NCOBJS) $(ocamloptcomp_NCOBJS) \
	  $(ocamltoplevel_NCOBJS) $(CROSSCOMPILERLIBS)
	$(MAKE) $(CROSSCOMPILERLIBS) $(CROSS_COMPILERLIBS_OVERRIDES) $(OLDS)

.PHONY: crosscompiledopt
crosscompiledopt:
	$(MAKE) ocamlc $(TOOLS_BYTECODE_TARGETS) expunge$(EXE) \
	  $(CROSS_COMPILER_OVERRIDES) $(OLDS)
	# Build stdlib directly (same reason as crossopt)
	$(MAKE) -C stdlib all CAMLC=ocamlc COMPILER_DEPS= $(CROSS_OVERRIDES) $(OLDS)
	$(MAKE) ocamlyacc $(CROSS_OVERRIDES) $(OLDS)
	$(MAKE) ocamllex $(CROSS_COMPILER_OVERRIDES) $(OLDS)
	$(MAKE) ocaml $(CROSS_COMPILER_OVERRIDES) $(OLDS)
	$(MAKE) dynlink-all $(CROSS_OVERRIDES) $(OLDS)
	$(MAKE) -C otherlibs all $(CROSS_OTHERLIBS_OVERRIDES) $(OLDS)
	$(MAKE) runtimeopt $(RUNTIME_VARS) $(OLDS)
	# Clean dynlink to prevent .cmi inconsistencies
	rm -f otherlibs/dynlink/*.cmx otherlibs/dynlink/*.cmi otherlibs/dynlink/*.o
	rm -f otherlibs/dynlink/native/*.cmx otherlibs/dynlink/native/*.cmi otherlibs/dynlink/native/*.o
	# Build native compilers (BUILD platform) with NATIVE tools via env vars
	CONDA_OCAML_AS="$(NATIVE_ASM)" CONDA_OCAML_CC="$(NATIVE_CC)" \
	  $(MAKE) ocamlc.opt ocamlopt.opt $(TOOLS_NATIVE_TARGETS) \
	  $(NATIVE_COMPILER_OVERRIDES) OCAMLOPT=$(CAMLOPT) "$(HOST_ZSTD_LIBS)" $(OLDS)
	# Build stdlib native with cross-compiler from _cross/bin (TARGET platform)
	$(MAKE) -C stdlib allopt CAMLOPT=$(CAMLOPT) OPTCOMPILER= COMPILER_DEPS= $(CROSS_OVERRIDES) $(OLDS)
	# Clean dynlink again before otherlibrariesopt
	@echo "=== Cleaning dynlink files before otherlibrariesopt ==="
	rm -fv otherlibs/dynlink/*.cmx otherlibs/dynlink/*.cmi otherlibs/dynlink/*.o 2>/dev/null || true
	rm -fv otherlibs/dynlink/native/*.cmx otherlibs/dynlink/native/*.cmi otherlibs/dynlink/native/*.o 2>/dev/null || true
	# Build otherlibs and tools with cross-compiler
	$(MAKE) otherlibrariesopt CAMLOPT=$(CAMLOPT) OCAMLOPT=$(CAMLOPT) BEST_OCAMLOPT=$(CAMLOPT) $(CROSS_OTHERLIBS_OVERRIDES) $(OLDS)
	$(MAKE) ocamltoolsopt CAMLOPT=$(CAMLOPT) $(CROSS_OTHERLIBS_OVERRIDES) $(OLDS)
	# Build native tools (ocamllex.opt) with NATIVE tools
	CONDA_OCAML_AS="$(NATIVE_ASM)" CONDA_OCAML_CC="$(NATIVE_CC)" \
	  $(MAKE) ocamltoolsopt.opt $(NATIVE_COMPILER_OVERRIDES) $(OLDS)
	# Copy stublibs to where the cross-compiler expects them (same as crossopt)
	@echo "=== Copying stublibs to $(LIBDIR)/stublibs ==="
	mkdir -p "$(LIBDIR)/stublibs"
	@for f in otherlibs/*/dll*.so; do \
	  if [ -f "$$f" ]; then \
	    echo "  Copying: $$f"; \
	    cp "$$f" "$(LIBDIR)/stublibs/"; \
	  fi; \
	done
	# We now build the compiler libs again, but for target this time
	rm -f $(ocamlcommon_NCOBJS) $(ocamlmiddleend_NCOBJS) \
	  $(ocamlbytecomp_NCOBJS) $(ocamloptcomp_NCOBJS) \
	  $(ocamltoplevel_NCOBJS) $(CROSSCOMPILERLIBS)
	$(MAKE) $(CROSSCOMPILERLIBS) $(CROSSCOMPILED_COMPILERLIBS_OVERRIDES) $(OLDS)

# ============================================================================
# crosscompiledruntime: Build runtime for TARGET platform
# conda-forge addition - builds native runtime after crosscompiledopt
# ============================================================================
# BYTECCLIBS/NATIVECCLIBS must be passed to recursive make for cross-compilation
# because configure detected libraries for BUILD platform, not TARGET.
# e.g., TARGET glibc 2.17 needs -ldl but BUILD glibc 2.34 doesn't.
.PHONY: crosscompiledruntime
crosscompiledruntime:
	$(MAKE) runtime-all $(RUNTIME_VARS) BYTECCLIBS='$(BYTECCLIBS)' NATIVECCLIBS='$(NATIVECCLIBS)' $(OLDS)

# ============================================================================
# Override otherlibraries targets to use CROSS_OTHERLIBS_OVERRIDES
# The main Makefile's otherlibraries/otherlibrariesopt don't pass CC/AR/MKLIB,
# causing wrong linker to be used for C stub libraries (otherlibs).
# ============================================================================
# CRITICAL: otherlibraries must use OCAMLLIB override to prevent bytecode CRC mismatches.
# Without this, bytecode libs rebuilt via this target (e.g., from install dependencies)
# would use OLD stdlib CRCs from native build instead of fresh ones.
# CRITICAL: Override otherlibraries to use OCAMLLIB and avoid unwanted rebuilds
# The upstream target has dependencies (ocamltools, dynlink-all) that can trigger
# bytecode rebuilds WITHOUT OCAMLLIB override, causing CRC mismatches.
# By removing prerequisites, we ensure this target ONLY builds otherlibs when explicitly called.
.PHONY: otherlibraries
otherlibraries:
	OCAMLLIB="$(LIBDIR)" $(MAKE) -C otherlibs all $(CROSS_OTHERLIBS_OVERRIDES)

.PHONY: otherlibrariesopt
otherlibrariesopt: dynlink-allopt
	$(MAKE) -C otherlibs allopt $(CROSS_OTHERLIBS_OVERRIDES)

# Cross-compilation variant: calls dynlink-allopt with proper compiler variables
# Use this instead of otherlibrariesopt when cross-compiling to avoid
# "inconsistent assumptions" errors (dynlink compiled with wrong compiler)
# Must pass ALL compiler variables: OCAMLOPT, CAMLOPT, BEST_OCAMLOPT
.PHONY: otherlibrariesopt-cross
otherlibrariesopt-cross:
	rm -f otherlibs/dynlink/*.cmx otherlibs/dynlink/*.cmi otherlibs/dynlink/*.o
	rm -f otherlibs/dynlink/native/*.cmx otherlibs/dynlink/native/*.cmi otherlibs/dynlink/native/*.o
	@echo "=== DEBUG: Removing old dynlink files from cross-compiler stdlib ==="
	rm -f $(OCAMLLIB)/dynlink*.cmi $(OCAMLLIB)/dynlink*.cmx $(OCAMLLIB)/dynlink*.cmo $(OCAMLLIB)/dynlink*.cma $(OCAMLLIB)/dynlink*.cmxa 2>/dev/null || true
	@echo "=== DEBUG: OCAMLLIB (make var) = $(OCAMLLIB)"
	@echo "=== DEBUG: OCAMLLIB (env) = $$OCAMLLIB"
	@echo "=== DEBUG: ocamlc stdlib = $$(ocamlc -config-var standard_library)"
	@echo "=== DEBUG: ocamlopt stdlib = $$($(CAMLOPT) -config-var standard_library)"
	export OCAMLLIB="$(OCAMLLIB)"; echo "=== DEBUG: After export, OCAMLLIB = $$OCAMLLIB"; $(MAKE) dynlink-allopt OCAMLOPT=$(CAMLOPT) CAMLOPT=$(CAMLOPT) BEST_OCAMLOPT=$(CAMLOPT) OCAMLLIB=$(OCAMLLIB) OC_NATIVE_COMPFLAGS="-verbose" $(CROSS_OVERRIDES)
	export OCAMLLIB="$(OCAMLLIB)"; $(MAKE) -C otherlibs allopt OCAMLLIB=$(OCAMLLIB) $(CROSS_OTHERLIBS_OVERRIDES)

.PHONY: cross-flexdll
cross-flexdll: | $(BYTE_BINDIR) $(OPT_BINDIR)
	rm -f $(FLEXDLL_SOURCE_DIR)/flexlink.exe
	$(MAKE) -C $(FLEXDLL_SOURCE_DIR) $(FLEXLINK_BUILD_ENV) \
	  NATDYNLINK=false LINKFLAGS= flexlink.exe support
	$(LN) $(FLEXDLL_SOURCE_DIR)/flexlink.exe flexlink.opt.exe
	$(LN) flexlink.opt.exe flexlink.byte.exe
	cp flexlink.byte.exe $(BYTE_BINDIR)/flexlink
	cd $(BYTE_BINDIR) && $(LN) flexlink flexlink.exe
	cp $(addprefix $(FLEXDLL_SOURCE_DIR)/, $(FLEXDLL_OBJECTS)) $(ROOTDIR)
	cp flexlink.opt.exe $(OPT_BINDIR)/flexlink
	cd $(OPT_BINDIR) && $(LN) flexlink flexlink.exe

# CRITICAL: INSTALLING=1 makes VPATH conditional skip in Makefile.cross line 43
# Without this, recursive makes re-include Makefile.cross and set VPATH := + $(VPATH)
# causing Make to find OLD unix.cmxa from native stdlib before fresh build in otherlibs/
INSTALL_OVERRIDES=build_ocamldoc=false WITH_DEBUGGER= OCAMLRUN=ocamlrun INSTALLING=1 VPATH=

.PHONY: installcross
installcross:
	# Create dummy files to keep `install` happy
	touch \
	  $(addprefix toplevel/, \
	    $(foreach ext,cmi cmt cmti cmx, native/nat__dummy__.$(ext)) \
	      all__dummy__.cmx topstart.o native/tophooks.cmi)
	# Only create symlinks if binaries don't exist (Stage 3 builds real binaries)
	test -f lex/ocamllex.opt$(EXE) || $(LN) `command -v ocamllex` lex/ocamllex.opt$(EXE)
	test -f yacc/ocamlyacc.opt$(EXE) || $(LN) `command -v ocamlyacc` yacc/ocamlyacc.opt$(EXE)
	# NOTE: Do NOT delete files from NATIVE_STDLIB here!
	# NATIVE_STDLIB is the installed native compiler that gets packaged.
	# Deleting unix.cma/.cmi from there breaks the native package.
	# VPATH pollution is prevented by INSTALLING=1 VPATH= in INSTALL_OVERRIDES.
	# Real installation (VPATH= is in INSTALL_OVERRIDES to propagate to recursive sub-makes)
	$(MAKE) install $(INSTALL_OVERRIDES)
