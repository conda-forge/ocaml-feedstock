# ============================================================================
# CROSS-COMPILERS BUILD SCRIPT
# Builds cross-compilers for aarch64/ppc64le (on linux-64) or arm64 (on osx-64)
#
# Variables:
#   OCAML_PREFIX         - Where native OCaml is installed (source for native tools)
#   OCAML_INSTALL_PREFIX - Where cross-compilers will be installed (destination)
# ============================================================================

# Source common functions
source "${RECIPE_DIR}/building/common-functions.sh"

if [[ "${target_platform}" != "linux"* ]] && [[ "${target_platform}" != "osx"* ]]; then
  echo "No cross-compiler recipe for ${target_platform} ... yet"
  return 0
fi

# ============================================================================
# Configuration
# ============================================================================

# OCAML_PREFIX = where native OCaml is installed (source for native tools)
# OCAML_INSTALL_PREFIX = where cross-compilers will be installed (destination)
: "${OCAML_PREFIX:=${PREFIX}}"
: "${OCAML_INSTALL_PREFIX:=${PREFIX}}"

# macOS: Set DYLD_LIBRARY_PATH so native compiler can find libzstd at runtime
# The native compiler (x86_64) needs BUILD_PREFIX libs, not PREFIX (which has target arch libs)
# Cross-compilation: PREFIX=ARM64, BUILD_PREFIX=x86_64
# Native build: PREFIX=x86_64, BUILD_PREFIX=x86_64 (same)
if [[ "${target_platform}" == "osx"* ]]; then
  if [[ "${CONDA_BUILD_CROSS_COMPILATION:-0}" == "1" ]]; then
    export DYLD_LIBRARY_PATH="${BUILD_PREFIX}/lib:${DYLD_LIBRARY_PATH:-}"
    export LIBRARY_PATH="${BUILD_PREFIX}/lib:${LIBRARY_PATH:-}"
  else
    export DYLD_LIBRARY_PATH="${PREFIX}/lib:${DYLD_LIBRARY_PATH:-}"
    export LIBRARY_PATH="${PREFIX}/lib:${LIBRARY_PATH:-}"
  fi
fi

# Define cross targets based on build platform
declare -a CROSS_TARGETS
case "${OCAML_CROSS_PLATFORM:-${target_platform}}" in
  linux-aarch64)
    CROSS_TARGETS=("aarch64-conda-linux-gnu")
    ;;
  linux-ppc64le)
    CROSS_TARGETS=("powerpc64le-conda-linux-gnu")
    ;;
  osx-arm64)
    CROSS_TARGETS=("arm64-apple-darwin20.0.0")
    ;;
esac

# ============================================================================
# Build loop
# ============================================================================

echo ""
echo "============================================================"
echo "Cross-compiler build configuration"
echo "============================================================"
echo "  Native OCaml (source):    ${OCAML_PREFIX}"
echo "  Cross install (dest):     ${OCAML_INSTALL_PREFIX}"
echo "  Native ocamlopt:          ${OCAML_PREFIX}/bin/ocamlopt"

for target in "${CROSS_TARGETS[@]}"; do
  echo ""
  echo "  ------------------------------------------------------------"
  echo "  Building cross-compiler for ${target}"
  echo "  ------------------------------------------------------------"

  # Get target properties using common functions
  CROSS_ARCH=$(get_target_arch "${target}")
  CROSS_PLATFORM=$(get_target_platform "${target}")

  # Handle PowerPC model override
  CROSS_MODEL=""
  [[ "${target}" == "powerpc64le-"* ]] && CROSS_MODEL="ppc64le"

  # Setup cross-toolchain (sets CROSS_CC, CROSS_AS, CROSS_AR, etc.)
  setup_toolchain "CROSS" "${target}"
  setup_cflags_ldflags "CROSS" "${build_platform}" "${CROSS_PLATFORM}"
  
  if [[ -z "${NATIVE_CC:-}" ]]; then
    setup_toolchain "NATIVE" "${CONDA_TOOLCHAIN_BUILD}"
    setup_cflags_ldflags "NATIVE" "${build_platform}" "${CROSS_PLATFORM}"
  fi
  
  # Export CONDA_OCAML_<TARGET_ID>_* variables
  TARGET_ID=$(get_target_id "${target}")

  echo "  Target:        ${target}"
  echo "  Target ID:     ${TARGET_ID}"
  echo "  Arch:          ${CROSS_ARCH}"
  echo "  Platform:      ${CROSS_PLATFORM}"
  echo "  CROSS_AR:      ${CROSS_AR}"
  echo "  CROSS_AS:      ${CROSS_AS}"
  echo "  CROSS_ASM:     ${CROSS_ASM}"
  echo "  CROSS_CC:      ${CROSS_CC}"
  echo "  CROSS_CFLAGS:  ${CROSS_CFLAGS}"
  echo "  CROSS_LD:      ${CROSS_LD}"
  echo "  CROSS_LDFLAGS: ${CROSS_LDFLAGS}"
  echo "  CROSS_RANLIB:  ${CROSS_RANLIB}"

  cat > "${SRC_DIR}/_xcross_compiler_${target_platform}_env.sh" << EOF
# Generated by build-cross-compiler.sh - do not edit
export "CROSS_AR=${CROSS_AR}"
export "CROSS_AS=${CROSS_AS}"
export "CROSS_ASM=${CROSS_ASM}"
export "CROSS_CC=${CROSS_CC}"
export "CROSS_CFLAGS=${CROSS_CFLAGS}"
export "CROSS_LD=${CROSS_LD}"
export "CROSS_LDFLAGS=${CROSS_LDFLAGS}"
export "CROSS_RANLIB=${CROSS_RANLIB}"
export "CROSS_MKDLL=${CROSS_MKDLL}"
export "CROSS_MKEXE=${CROSS_MKEXE}"

# CONDA_OCAML_* for runtime (use CROSS_* not CONDA_OCAML_* which may be native)
export "CONDA_OCAML_${TARGET_ID}_AR=${CROSS_AR}"
export "CONDA_OCAML_${TARGET_ID}_AS=${CROSS_ASM}"
export "CONDA_OCAML_${TARGET_ID}_CC=${CROSS_CC}"
export "CONDA_OCAML_${TARGET_ID}_RANLIB=${CROSS_RANLIB}"
export "CONDA_OCAML_${TARGET_ID}_MKDLL=${CROSS_MKDLL}"
export "CONDA_OCAML_${TARGET_ID}_MKEXE=${CROSS_MKEXE}"
EOF

  # Installation prefix for this cross-compiler
  OCAML_CROSS_PREFIX="${OCAML_INSTALL_PREFIX}/lib/ocaml-cross-compilers/${target}"
  OCAML_CROSS_LIBDIR="${OCAML_CROSS_PREFIX}/lib/ocaml"
  mkdir -p "${OCAML_CROSS_PREFIX}/bin" "${OCAML_CROSS_LIBDIR}"

  # ========================================================================
  # Clean and configure
  # ========================================================================

  echo "  [1/5] Cleaning previous build..."
  run_logged "pre-cross-distclean" "${MAKE[@]}" distclean > /dev/null 2>&1 || true

  echo "  [2/5] Configuring for ${target}..."
  # PKG_CONFIG=false forces simple "-lzstd" instead of "-L/long/path -lzstd"
  # Do NOT pass CC here - configure needs BUILD compiler
  # ac_cv_func_getentropy=no: conda-forge uses glibc 2.17 sysroot which lacks getentropy
  # CRITICAL: Override CFLAGS/LDFLAGS - conda-build sets them for TARGET (ppc64le)
  # but configure needs BUILD flags (x86_64) to compile the cross-compiler binary

  # Frame pointers only supported on amd64 and arm64, not on ppc64le
  FRAME_POINTERS_FLAG=""
  if [[ "${target}" != *"ppc64le"* && "${target}" != *"powerpc64le"* ]]; then
    FRAME_POINTERS_FLAG="--enable-frame-pointers"
  fi

  run_logged "cross-configure" ${CONFIGURE[@]} \
    -prefix="${OCAML_CROSS_PREFIX}" \
    --host="${build_alias}" \
    --target="${target}" \
    ${FRAME_POINTERS_FLAG} \
    "${CONFIG_ARGS[@]}" \
    AR="${CROSS_AR}" \
    AS="${NATIVE_AS}" \
    CC="${NATIVE_CC}" \
    CFLAGS="${NATIVE_CFLAGS}" \
    LD="${NATIVE_LD}" \
    LDFLAGS="${NATIVE_LDFLAGS}" \
    NM="${CROSS_NM}" \
    RANLIB="${CROSS_RANLIB}" \
    STRIP="${CROSS_STRIP}" \
    ac_cv_func_getentropy=no \
    ${CROSS_MODEL:+MODEL=${CROSS_MODEL}}

  # ========================================================================
  # Patch config.generated.ml
  # ========================================================================

  echo "  [3/5] Patching config.generated.ml..."
  config_file="utils/config.generated.ml"

  # Remove -L paths from bytecomp_c_libraries (embedded in ocamlc binary)
  # Use more specific pattern to avoid affecting other content
  sed -i 's#\(bytecomp_c_libraries.*\)-L[^ ]*#\1#g' "$config_file"
  sed -i 's#\(compression_c_libraries.*\)-L[^ ]*#\1#g' "$config_file"

  # Patch the cross-compiler's config to use the correct tools
  # - Use DIRECT cross-assembler path (not wrapper) - avoids CONDA_OCAML_AS env var confusion
  #   The native ocamlopt uses conda-ocaml-as wrapper with CONDA_OCAML_AS from _native_env.sh (x86_64-as)
  #   The cross ocamlopt.opt needs aarch64-as directly - using wrapper would use wrong assembler
  # - Use wrappers for other tools (cc, ar, etc.) - they need runtime flexibility
  sed -i \
    -e "s#^let asm = .*#let asm = {|${CROSS_ASM}|}#" \
    -e 's#^let ar = .*#let ar = {|conda-ocaml-ar|}#' \
    -e 's#^let c_compiler = .*#let c_compiler = {|conda-ocaml-cc|}#' \
    -e 's#^let ranlib = .*#let ranlib = {|conda-ocaml-ranlib|}#' \
    -e 's#^let mkexe = .*#let mkexe = {|conda-ocaml-mkexe|}#' \
    -e 's#^let mkdll = .*#let mkdll = {|conda-ocaml-mkdll|}#' \
    -e 's#^let mkmaindll = .*#let mkmaindll = {|conda-ocaml-mkdll|}#' \
    "$config_file"
  sed -i "s#^let standard_library_default = .*#let standard_library_default = {|${OCAML_CROSS_LIBDIR}|}#" "$config_file"
  [[ -n "${CROSS_MODEL}" ]] && sed -i "s#^let model = .*#let model = {|${CROSS_MODEL}|}#" "$config_file"

  # Apply Makefile patches
  patch -N -p0 < "${RECIPE_DIR}/building/tmp_Makefile.patch" > /dev/null 2>&1 || true

  # Patch Makefile.cross directly (using sed -r file is more reliable than multiline append)
  # Add SAK build variables for cross-compilation (SAK must run on BUILD machine)
  if ! grep -q "SAK_CC" Makefile.cross; then
    cat > /tmp/sak_vars.txt << 'SAK_VARS_EOF'

# Export OCAMLLIB so bytecode compiler (ocamlc) sees cross-compiler's stdlib
export OCAMLLIB

# SAK_CC and SAK_LINK should be set to build-machine compiler when cross-compiling
# SAK is a build tool that must run on the BUILD machine, not the TARGET
# CRITICAL: SAK_LDFLAGS must be BUILD-machine flags, NOT TARGET LDFLAGS
SAK_CC ?= $(CC)
SAK_CFLAGS ?= $(CFLAGS)
SAK_LDFLAGS ?= $(LDFLAGS)
SAK_LINK ?= $(SAK_CC) $(OC_LDFLAGS) $(SAK_LDFLAGS) $(OUTPUTEXE)$(1) $(2)
SAK_BUILD = $(SAK_LINK) $(OC_CFLAGS) $(SAK_CFLAGS) $(OC_CPPFLAGS) $(CPPFLAGS)

# Cross-compilation tool overrides (can be set from command line)
CROSS_CC ?= $(CC)
CROSS_AR ?= $(AR)
CROSS_MKLIB ?= ocamlmklib
CAMLOPT ?= ocamlopt
SAK_VARS_EOF
    sed -i "/^HOST_ZSTD_LIBS=/r /tmp/sak_vars.txt" Makefile.cross
    rm -f /tmp/sak_vars.txt
  fi

  # Update CROSS_OVERRIDES to include CC/AR/MKLIB and bypass file dependencies
  if ! grep -q 'CAMLC=ocamlc MKLIB' Makefile.cross; then
    # COMPILER_DEPS= bypasses file dependency on ocamlc binary (stdlib expects ocamlc file to exist)
    # OPTCOMPILER= bypasses file dependency on ocamlopt binary for allopt targets
    sed -i 's/BOOT_OCAMLLEX=ocamllex OCAMLYACC=ocamlyacc$/BOOT_OCAMLLEX=ocamllex OCAMLYACC=ocamlyacc \\\n  CAMLC=ocamlc MKLIB="$(CROSS_MKLIB)" \\\n  CC="$(CROSS_CC)" AR="$(CROSS_AR)" \\\n  COMPILER_DEPS= OPTCOMPILER=/' Makefile.cross
  fi

  # CRITICAL: Make libraryopt and otherlibrariesopt use the cross-compiler
  # By default, CROSS_OVERRIDES uses CAMLOPT=ocamlopt (native from PATH), which generates x86_64 code.
  # But TARGET libraries need ARM64/PPC64 code, so we must use the cross-compiler.
  # NOTE: Use $(abspath $(ROOTDIR)) because ROOTDIR=. doesn't work from subdirectories
  if ! grep -q 'CAMLOPT="\$(abspath' Makefile.cross; then
    # Add CAMLOPT to CROSS_OVERRIDES to use the cross-compiler for TARGET code
    # $(abspath $(ROOTDIR)) evaluates to absolute path, works from any subdirectory
    sed -i 's/CC="\$(CROSS_CC)" AR="\$(CROSS_AR)"/CC="\$(CROSS_CC)" AR="\$(CROSS_AR)" \\\n  CAMLOPT="\$(abspath \$(ROOTDIR))\/ocamlopt.opt"/' Makefile.cross
  fi

  # ========================================================================
  # Pre-build bytecode runtime with NATIVE tools
  # ========================================================================

  # runtime-all builds BOTH:
  # - ocamlrun* (bytecode interpreter) - must run on BUILD machine → NATIVE tools
  # - libasmrun* (native runtime) - for TARGET → CROSS tools
  # We can't use one set of tools for both. Solution:
  # 1. Build just runtime_PROGRAMS (ocamlrun*) with NATIVE tools first
  # 2. Then let crossopt build libasmrun* with CROSS tools
  # crossopt's runtime-all dependency will be satisfied by existing ocamlrun

  echo "  [4/6] Pre-building bytecode runtime with native tools..."

  # runtime-all builds BOTH bytecode (libcamlrun*) and native (libasmrun*) runtimes.
  # For cross-compilation:
  # - Bytecode runtime (libcamlrun*, ocamlrun*) runs on BUILD machine → NATIVE tools
  # - Native runtime (libasmrun*) is for TARGET → CROSS tools
  #
  # Strategy:
  # 1. Build runtime-all with NATIVE tools (ARCH=amd64) - produces x86_64 everything
  # 2. Clean native runtime files (libasmrun*, amd64.o) - ARM64 needs these rebuilt
  # 3. crossopt rebuilds libasmrun* with CROSS tools (ARCH=arm64)
  #    (bytecode parts already exist and won't be rebuilt)
  run_logged "runtime-all" "${MAKE[@]}" runtime-all \
    ARCH=amd64 \
    CC="${NATIVE_CC}" \
    CFLAGS="${NATIVE_CFLAGS}" \
    LD="${NATIVE_LD}" \
    LDFLAGS="${NATIVE_LDFLAGS}" \
    SAK_CC="${NATIVE_CC}" \
    SAK_CFLAGS="${NATIVE_CFLAGS}" \
    SAK_LDFLAGS="${NATIVE_LDFLAGS}" \
    ZSTD_LIBS="-L${BUILD_PREFIX}/lib -lzstd" \
    -j"${CPU_COUNT}" || {
    echo "     FAILED - see log"
    exit 1
  }
  echo "     OK"

  # Clean native runtime files so crossopt rebuilds them for TARGET arch
  # - libasmrun*.a: native runtime static libraries
  # - libasmrun_shared.so: native runtime shared library
  # - amd64*.o: x86_64 assembly objects (crossopt needs arm64*.o)
  # - *.nd.o, *.ni.o, *.npic.o: native code object files (need CROSS CC)
  echo "     Cleaning native runtime for crossopt rebuild..."
  rm -f runtime/libasmrun*.a runtime/libasmrun_shared.so
  rm -f runtime/amd64*.o runtime/*.nd.o runtime/*.ni.o runtime/*.npic.o
  rm -f runtime/libcomprmarsh.a  # Also needs CROSS tools

  # ========================================================================
  # Build cross-compiler
  # ========================================================================

  echo "  [5/6] Building cross-compiler (crossopt)..."

  (
    # Set CONDA_OCAML_* for cross-compilation during build
    # NOTE: CC/AS/AR/RANLIB are CROSS tools (for compiling ARM64/PPC64 stdlib)
    # BUT: MKEXE must stay NATIVE (for linking the x86_64 cross-compiler binary)
    # CONDA_OCAML_MKEXE inherits native value from _native_env.sh - DO NOT override!
    #
    # CRITICAL: Do NOT override CONDA_OCAML_AS here!
    # - Native ocamlopt (used via CAMLOPT=ocamlopt) needs NATIVE assembler for tools like profiling.cmx
    # - The _native_env.sh already set CONDA_OCAML_AS to native assembler
    # - Cross stdlib assembly is handled by passing AS="${CROSS_AS}" to make
    #
    # CRITICAL: Must EXPORT these so ocaml-* wrapper scripts see them
    export CONDA_OCAML_CC="${CROSS_CC}"
    export CONDA_OCAML_AR="${CROSS_AR}"
    export CONDA_OCAML_RANLIB="${CROSS_RANLIB}"
    export CONDA_OCAML_MKDLL="${CROSS_MKDLL}"
    # CONDA_OCAML_MKEXE intentionally NOT set - use native linker for cross-compiler binary
    # CONDA_OCAML_AS intentionally NOT overridden - native ocamlopt needs native assembler

    # Ensure cross-tools are findable in PATH
    PATH="${OCAML_PREFIX}/bin:${PATH}"
    hash -r

    # Build arguments
    CROSSOPT_ARGS=(
      ARCH="${CROSS_ARCH}"
      AR="${CROSS_AR}"
      AS="${CROSS_AS}"
      ASPP="${CROSS_CC} -c"
      CAMLOPT=ocamlopt
      CC="${CROSS_CC}"
      CFLAGS="${CROSS_CFLAGS}"
      CROSS_AR="${CROSS_AR}"
      CROSS_CC="${CROSS_CC}"
      CROSS_MKLIB="${RECIPE_DIR}/building/cross-ocamlmklib.sh"
      LD="${CROSS_LD}"
      LDFLAGS="${CROSS_LDFLAGS}"
      LIBDIR="${OCAML_CROSS_LIBDIR}"
      NM="${CROSS_NM}"
      RANLIB="${CROSS_RANLIB}"
      STRIP="${CROSS_STRIP}"
      ZSTD_LIBS="-L${BUILD_PREFIX}/lib -lzstd"
      
      SAK_AR="${NATIVE_AR}"
      SAK_CC="${NATIVE_CC}"
      SAK_CFLAGS="${NATIVE_CFLAGS}"
      SAK_LDFLAGS="${NATIVE_LDFLAGS}"

      # NATIVE_AS/ASM/CC for building native tools (profiling.cmx, ocamlopt.opt internals)
      # Makefile.cross defaults to "as" and $(CC) which are wrong during cross-compilation
      # NATIVE_ASM includes "-c" flag for macOS clang (required for assembly-only)
      NATIVE_AS="${NATIVE_AS}"
      NATIVE_ASM="${NATIVE_ASM}"
      NATIVE_CC="${NATIVE_CC}"
    )

    run_logged "crossopt" "${MAKE[@]}" crossopt "${CROSSOPT_ARGS[@]}" -j"${CPU_COUNT}"
  )

  # ========================================================================
  # Install cross-compiler
  # ========================================================================

  echo "  [6/6] Installing cross-compiler artifacts..."

  # Binaries
  cp ocamlopt.opt "${OCAML_CROSS_PREFIX}/bin/"
  cp ocamlc.opt "${OCAML_CROSS_PREFIX}/bin/"
  cp tools/ocamldep.opt "${OCAML_CROSS_PREFIX}/bin/"
  cp tools/ocamlobjinfo.opt "${OCAML_CROSS_PREFIX}/bin/"

  # Stdlib (bytecode + native + metadata)
  cp stdlib/*.{cma,cmxa,a,cmi,cmo,cmx,o} "${OCAML_CROSS_LIBDIR}/" 2>/dev/null
  cp stdlib/*runtime*info "${OCAML_CROSS_LIBDIR}/" 2>/dev/null

  # Compiler libs
  cp compilerlibs/*.{cma,cmxa,a} "${OCAML_CROSS_LIBDIR}/" 2>/dev/null

  # Runtime
  cp runtime/*.{a,o} "${OCAML_CROSS_LIBDIR}/" 2>/dev/null

  # Otherlibs
  for lib in otherlibs/*/; do
    cp "${lib}"*.{cma,cmxa,a,cmi,cmo,cmx,o} "${OCAML_CROSS_LIBDIR}/" 2>/dev/null
  done

  # Stublibs
  mkdir -p "${OCAML_CROSS_LIBDIR}/stublibs"
  cp otherlibs/*/dll*.so "${OCAML_CROSS_LIBDIR}/stublibs/" 2>/dev/null

  # ld.conf - point to native OCaml's stublibs (same arch as cross-compiler binary)
  # Cross-compiler binary runs on BUILD machine, needs BUILD-arch stublibs
  cat > "${OCAML_CROSS_LIBDIR}/ld.conf" << EOF
${OCAML_PREFIX}/lib/ocaml/stublibs
${OCAML_PREFIX}/lib/ocaml
EOF

  # ========================================================================
  # Generate wrapper scripts
  # ========================================================================

  for tool in ocamlopt ocamlc ocamldep ocamlobjinfo; do
    generate_cross_wrapper "${tool}" "${OCAML_INSTALL_PREFIX}" "${target}" "${OCAML_CROSS_PREFIX}"
  done

  echo "  Installed: ${OCAML_INSTALL_PREFIX}/bin/${target}-ocamlopt"
  echo "  Libs:      ${OCAML_CROSS_LIBDIR}/"

  # ========================================================================
  # Test cross-compiler
  # ========================================================================

  echo "  Testing cross-compiler..."
  "${OCAML_INSTALL_PREFIX}/bin/${target}-ocamlopt" -version | grep -q "${PKG_VERSION}"

  cat > /tmp/test_xcross_compiler.ml << 'TESTEOF'
let () = print_endline "Hello from cross-compiled OCaml"
TESTEOF

  if "${OCAML_INSTALL_PREFIX}/bin/${target}-ocamlopt" -o /tmp/test_xcross_compiler /tmp/test_xcross_compiler.ml 2>/dev/null; then
    _file_output=$(file /tmp/test_xcross_compiler)
    case "${CROSS_ARCH}" in
      arm64)
        echo "$_file_output" | grep -qiE "aarch64|arm64" && echo "  ✓ Produces ${CROSS_ARCH} binaries" || {
          echo "  ✗ ERROR: expected ${CROSS_ARCH}, got: $_file_output"
          exit 1
        }
        ;;
      power)
        echo "$_file_output" | grep -qi "powerpc\|ppc64" && echo "  ✓ Produces ${CROSS_ARCH} binaries" || {
          echo "  ✗ ERROR: expected ${CROSS_ARCH}, got: $_file_output"
          exit 1
        }
        ;;
    esac
    rm -f /tmp/test_xcross_compiler /tmp/test_xcross_compiler.ml /tmp/test_xcross_compiler.{o,cmx,cmi}
  else
    echo "  ✗ ERROR: cross-compilation failed"
    "${OCAML_INSTALL_PREFIX}/bin/${target}-ocamlopt" -verbose -o /tmp/test_xcross_compiler /tmp/test_xcross_compiler.ml || true
    exit 1
  fi

  echo "  Done: ${target}"
done

echo ""
echo "============================================================"
echo "All cross-compilers built successfully"
echo "============================================================"
